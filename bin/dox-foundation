#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander'),
    util = require('util'),
    dox = require('dox'),
    _ = require('underscore'),
    formatter = require('../lib/dox-foundation');

/**
 * Options & Defaults
 */

var ignoredDirs = 'test,public,static,views,templates';

program
  .version(formatter.version)
  .option('-r, --raw', 'output "raw" comments, leaving the markdown intact')
  .option('-d, --debug', 'output parsed comments for debugging')
  .option('-t, --title <string>', 'The title for the page produced')
  .option('-s, --source <source>', 'The folder which should get parsed')
  .option('-i, --ignore <directories>', 'Comma seperated list of directories to ignore. Default: ' + ignoredDirs)
  .option('-T, --target <target>', 'The folder which will contain the results. Default: <process.cwd()>/docs');

// examples
program.on('--help', function(){
  console.log('  Examples:');
  console.log('');
  console.log('    # stdin');
  console.log('    $ dox-foundation > myfile.html');
  console.log('');
  console.log('    # operates over stdio');
  console.log('    $ dox-foundation < myfile.js > myfile.html');
  console.log('');
  console.log('    # parse a whole folder');
  console.log('    $ dox-foundation --source ./lib --target ./docs');
});

// parse argv

program.parse(process.argv);

if (program.source) {
  // process a folder

  var walk    = require('walk'),
      fs      = require('fs'),
      target  = program.target || process.cwd() + '/docs',
      source  = program.source,
      files   = [],
      folders = [],
      ignore  = program.ignore || ignoredDirs;

  // Cleanup and turn into an array the ignoredDirs
  ignore = ignore.trim().replace(' ','').split(',');

  // Walker options
  var walker  = walk.walk(source, { followLinks: false })

  walker.on('file', function(root, stat, next) {
    
    // Ignore iterator
    var notInIgnored = function(d){
      return (root.indexOf(d) === -1)
    }

    // If the file is: a JS file and not in an ignored dir continue
    if (stat.name.substr(-2) === 'js' && _.all(ignore, notInIgnored)) {
      var folder = root.replace(source, '').trim()

      if ((folder !== '') && (folders.indexOf(folder) === -1)) {
        folders.push(folder)
      }

      files.push(root + '/' + stat.name)
    }

    next()
  });

  walker.on('end', function() {
    var data = []

    try { fs.mkdirSync(target) } catch(e) {}

    folders.forEach(function(folder) {
      try { fs.mkdirSync(target + '/' + folder) } catch(e) {}
    })

    files.forEach(function(file) {
      try {
        var content = fs.readFileSync(file).toString()
        var dataObj = {
          sourceFile: file,
          targetFile: file.replace(source, target) + '.html',
          dox:        dox.parseComments(content, { raw: program.raw })
        }

        data.push(dataObj)
      } catch(e) { console.log(e) }
    })

    var structure = data.reduce(function(structure, data) {
      var addFragmentToHash = function(hash, fragment) {
        var match = fragment.match(/^(.*?\/)/)

        if (!!match) {
          var key = match[1].replace('/', '')
          hash[key] = hash[key] || {}
          addFragmentToHash(hash[key], fragment.substr(match[1].length))
        } else {
          hash[fragment] = data.targetFile
        }
      }

      var _source = data.sourceFile.replace(source, '')

      if (_source.charAt(0) === '/') {
        _source = _source.substr(1)
      }

      addFragmentToHash(structure, _source)

      return structure
    }, {})

    var finalStructure = {}

    for (var key in structure) {
      if (structure.hasOwnProperty(key)) {
        var value = structure[key]

        if (typeof value === 'string') {
          finalStructure['/'] = finalStructure['/'] || {}
          finalStructure['/'][key] = value
        } else {
          finalStructure[key] = value
        }
      }
    }

    data.forEach(function(data) {
      var options = { title: program.title, folderStructure: finalStructure }
        , output  = formatter.parse(data.dox, options)

      fs.writeFileSync(data.targetFile, output)
    })
  });
} else {
  // process stdin

  var buf = '';
  process.stdin.setEncoding('utf8');
  process.stdin.on('data', function(chunk){ buf += chunk; });
  process.stdin.on('end', function(){
    // Run the buffer through Dox
    var obj = dox.parseComments(buf, { raw: program.raw });
    // If debug, just throw out the dox json
    if (program.debug) {
      process.stdout.write(util.inspect(obj, false, Infinity, true) + '\n');
    } else {
      // Run the json to be formatted and dumped to stdout
      var output = formatter.parse(obj, { title: program.title, folderStructure: null });
      process.stdout.write(output);
    }
  }).resume();
}
